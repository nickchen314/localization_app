<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>plan_update</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="progress_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="progress_report_files/libs/quarto-html/quarto.js"></script>
<script src="progress_report_files/libs/quarto-html/popper.min.js"></script>
<script src="progress_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="progress_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="progress_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="progress_report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="progress_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="progress_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="progress_report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">plan_update</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="project-plan-update" class="level2">
<h2 class="anchored" data-anchor-id="project-plan-update">Project Plan Update</h2>
<p>Nick C, Kento H, Orion F, Tristan L. Data-412 (all members)</p>
<section id="update-on-contextproblem" class="level3">
<h3 class="anchored" data-anchor-id="update-on-contextproblem">Update on context/problem</h3>
<p>To better refine our use case, we consulted with researchers from American University’s Accountability Research Center who specialize in foreign aid flow. Based on that conversation, minimal revisions on our projects context and problem are required. In terms of use case, it was suggested that there is currently a far bigger focus on prime awards by researchers and development professionals as opposed to sub-awards. Thus, we have decided to prioritize creating a clear analysis of prime award localization as a minimal viable product before analyzing sub-awards.</p>
</section>
<section id="ethical-review" class="level3">
<h3 class="anchored" data-anchor-id="ethical-review">Ethical Review</h3>
<p>There are minimal updates regarding our ethical review. Given that we are dealing with open source government data which has already been redacted to eliminate any safety/privacy issues, we are confident that our project has no major ethical concerns.</p>
<p>As discussed in the initial project plan, our group has continued discussing how to prevent the misrepresentation of our data. This means that we have taken measures such as drafting text for an into tab which details the limitations of our data set.</p>
</section>
<section id="progress-on-data-sourcing-and-cleaning" class="level3">
<h3 class="anchored" data-anchor-id="progress-on-data-sourcing-and-cleaning">Progress on Data Sourcing and Cleaning:</h3>
<p>Our proposed data source of USASpending.gov USAID awards data remains the same. We have two main functions in our .R file which focus on data sourcing, cleaning, and tidying:</p>
<p>API Functionality (func_call_api.R): A framework has been established for the function that will handle API requests to USASpending. The next step will be to complete the logic necessary to obtain the data. This will be additional functionality added after we have a minimila viable product.</p>
<p>Data Cleaning (func_clean_df.R): We created a strong data cleansing tool to handle raw data from contracts and grants. It guarantees that column names are consistent across data sets, combines the data into a single frame, and uses country codes to distinguish between local and non-local awards. It also corrects country code inconsistencies.</p>
</section>
<section id="progress-on-application-development-app.r" class="level3">
<h3 class="anchored" data-anchor-id="progress-on-application-development-app.r">Progress on Application Development (app.R):</h3>
<p>Our finalized app layout with contain two tabs:</p>
<p>One of the tabs accessible in the Shiny app will be a world map. This was part of our original plan, but has been expanded upon. The current plan is to create an interface wherein the user is presented with a map of the world, and when they click on one of its countries they are given a breakdown of the relevant data for said country.</p>
<p>The second tab will contain a stacked bar chart and scatter plot which contain overall summary data for global localization. The stacked bar chart will fill based on a boolean indicator of local funding (local vs non local) with aid in USD for the y-axis and fiscal year for the x axis. The scatter plot will plot localization percentages vs total aid, filling by continent with pop-up labels for country name.</p>
</section>
<section id="user-options" class="level3">
<h3 class="anchored" data-anchor-id="user-options">User options</h3>
<p>Our project contains minimal revisions in terms of user data manipulation and graphical analysis. We still plan on allowing users to filter based on country, fiscal year, local vs non-local funding and award type (contract vs grant). All refinements of user visualization options are discussed above.</p>
<p>In terms of statistical analysis, we have considered allowing users to conduct some form of bivariate analysis on individual awards data to analyze what factors impact a countries localization percentage. Given that this is not a required component of the project and the fact that potential app users seem more interested in clear visualizations of the data, we will add this feature only after having a minimally viable product.</p>
</section>
<section id="risk-assesment" class="level3">
<h3 class="anchored" data-anchor-id="risk-assesment">Risk Assesment</h3>
<p>Potential risks to completion included failing to create a sufficiently clean data set in a reasonable time to allow for work on other project module and a failure for individual standalone app modules to integrate into the final product.</p>
<p>To mitigate the first problem, we have used a csv of sample data to develop a data cleaning function which allows for work on all other app features. Our minimal viable product will be based on this sample data set, only integrating an API if there is sufficient time.</p>
<p>Similarly, we have refined our development approach to focus on collectively creating a minimal viable product instead of standalone modules which don’t necessarily work together. Our new development approach prioritizes essential features which eliminates the risks associated with non-compatability of app modules.</p>
</section>
<section id="outline" class="level3">
<h3 class="anchored" data-anchor-id="outline">Outline</h3>
<p>Data cleaning and gathering (completed) - Nick<br>
App design and UI, user selection options - Nick: (11/20) 3 Hours<br>
Mapping tab - Orion: (12/1) 5 hours<br>
Graphing tab - Kento and Tristan: (12/1) 5 hours<br>
Optional features after MVP<br>
API (Nick)<br>
Interactive map pins (Orion)<br>
Subaward Integration<br>
Presentation rehearsal: (12/9)<br>
Vignette (Tristan, Kento, Orion): (12/9)</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>